package genParserCode

type GenParserCodeTableInfo struct {
	PackageName        string
	ClassName          string
	LineClassName      string
	TableTemplate      string                    // read template data
	LineFieldList      []*GenParserCodeFieldInfo // read template data
	IsNeedImportString string                    //"strings"
}
type GenParserCodeFieldInfo struct {
	FieldTemplate string
}

const codeTemplate = `// Generated by gen-tool
// DO NOT EDIT!
package {{.PackageName}}

import (
	"errors"
	"fmt"
	"github.com/Blizzardx/GoConfigTool/common"
	"strconv"
	{{.IsNeedImportString}}
)

func parserConfig_{{.ClassName}}(decoder common.ConfigDecoder, configContent [][]string) ([]byte, error) {
	{{.TableTemplate}}

	content, err := decoder.Encode(table)
	if nil != err {
		return nil, err
	}
	return content.([]byte), nil
}
func parserLine_{{.ClassName}}(lineContent []string) (*{{.LineClassName}}, error) {
	line := &{{.LineClassName}}{}
	var err error = nil
	columnIndex := 0

{{range .LineFieldList}}
	{{.FieldTemplate}}
	{{end}}

	return line, nil
}

`

type GenParserCode_TableList struct {
	ClassName string
}

const codeTemplate_TableList = `

	table := &{{.ClassName}}{}
	for line, lineContent := range configContent {
		lineElem, err :=parserLine_{{.ClassName}}(lineContent)
		if nil != err {
			str := fmt.Sprintf("error on load config itemConfigTable at line: " + strconv.Itoa(line+1) + " " + err.Error())
			return nil, errors.New(str)
		}
		table.Content = append(table.Content, lineElem)
	}

`

type GenParserCode_TableMap struct {
	ClassName       string
	LineClassName   string
	MapKeyFieldName string
}

const codeTemplate_TableMap = `

	table := &{{.ClassName}}{}
	table.Content = map[int32]*{{.LineClassName}}{}
	for line, lineContent := range configContent {
		lineElem, err := parserLine_{{.ClassName}}(lineContent)
		if nil != err {
			str := fmt.Sprintf("error on load config itemConfigTable at line: " + strconv.Itoa(line+1) + " " + err.Error())
			return nil, errors.New(str)
		}

		if v, ok := table.Content[lineElem.{{.MapKeyFieldName}}]; ok {
			str := fmt.Sprintf("error on load config itemConfigTable at line: "+strconv.Itoa(line+1)+" key {{.MapKeyFieldName}} already in table ", v)
			return nil, errors.New(str)
		}
		table.Content[lineElem.{{.MapKeyFieldName}}] = lineElem
	}

`

type GenParserCode_Field struct {
	FieldType          string
	FieldName          string
	LimitCheckTemplate string
}

const codeTemplate_Field = `

	err = common.Parser_{{.FieldType}}(lineContent[columnIndex], &line.{{.FieldName}})
	if nil != err {
		return nil, errors.New(" column " + strconv.Itoa(columnIndex) + " named {{.FieldName}} " + err.Error())
	}

	{{.LimitCheckTemplate}}

	columnIndex++

`

const codeTemplate_FieldEmpty = `
	columnIndex++
`

type GenParserCode_CheckFieldLimit struct {
	FieldType     string
	FieldName     string
	FieldLimitMin string
	FieldLimitMax string
}

const codeTemplate_CheckFieldLimit = `

	err = common.CheckValueLimit_{{.FieldType}}(line.{{.FieldName}}, "{{.FieldLimitMin}}", "{{.FieldLimitMax}}")
	if err != nil {
		return nil, errors.New(" column " + strconv.Itoa(columnIndex) + " named {{.FieldName}} error on check min and max" + err.Error())
	}

`

type GenParserCode_FieldList struct {
	FieldType          string
	FieldName          string
	LimitCheckTemplate string
}

const codeTemplate_FieldList = `

	for _,lineElem := range strings.Split(lineContent[columnIndex],"|"){
		var elem {{.FieldType}} 
		err = common.Parser_{{.FieldType}}(lineElem, &elem)
		if nil != err {
			return nil, errors.New(" column " + strconv.Itoa(columnIndex)  + err.Error())
		}
		
		{{.LimitCheckTemplate}}
		
		{{.FieldName}} = append({{.FieldName}},elem)
	}
	columnIndex++

`

type GenParserCode_CheckFieldListLimit struct {
	FieldType     string
	FieldLimitMin string
	FieldLimitMax string
}

const codeTemplate_CheckFieldListLimit = `

	err = common.CheckValueLimit_{{.FieldType}}(elem, "{{.FieldLimitMin}}", "{{.FieldLimitMax}}")
	if err != nil {
		return nil, errors.New(" column " + strconv.Itoa(columnIndex) + "  error on check min and max" + err.Error())
	}

`

type GenParserCode_Main struct {
	ConfigList  []*GenParserCode_MainConfigElem
	Decoder     string
	PackageName string
}
type GenParserCode_MainConfigElem struct {
	ConfigName string
}

const codeTemplate_Main = `

package {{.PackageName}}

import (
	"fmt"
	"github.com/Blizzardx/GoConfigTool/excelConfigParserTool/excelHandler"
	"github.com/Blizzardx/GoConfigTool/common"
	"github.com/Blizzardx/GoConfigTool/decoder"
)

var handlerMap = map[string]func(common.ConfigDecoder, [][]string) ([]byte, error){}

func init() {
{{range .ConfigList}}
	registerParserFunc("{{.ConfigName}}", parserConfig_{{.ConfigName}}Config)
	{{end}}

}
func registerParserFunc(configName string, handler func(common.ConfigDecoder, [][]string) ([]byte, error)) {
	handlerMap[configName] = handler
}
func ParserConfig(configName string, inputDir string, outputPath string) {
	handler := handlerMap[configName]
	if nil == handlerMap {
		fmt.Println("error on get handler by config name ", configName)
		return
	}
	// read config
	content, err := excelHandler.ReadExcelFile(inputDir + "/" + configName + ".xlsx")
	if nil != err {
		fmt.Println("error on get file provison file ", err.Error(), configName)
		return
	}
	result, err := handler(&decoder.{{.Decoder}}{}, excelHandler.FixExcelFile(content))
	if nil != err {
		fmt.Println("error on parser config ", err.Error(), configName)
		return
	}
	err = common.WriteFileByName(outputPath+"/"+configName+".bytes", result)
	if nil != err {
		fmt.Println("error on write result config ", err.Error(), configName)
		return
	}
}
func ParserAllConfig(outputPath string, inputDir string) {
	for fileName := range handlerMap {
		ParserConfig(fileName, inputDir, outputPath)
	}
}


`

type GenParserCode_Launch struct {
	ImportPackage string
	PackageName   string
	//"github.com/Blizzardx/GoConfigTool/excelConfigParserTool/z_example/sampleWorkspace/classDefineDir/auto"
}

const codeTemplate_Launch = `
package main

import (
	"fmt"
	"{{.ImportPackage}}"
	"os"
)

	func main() {
	if len(os.Args) < 3 {

		fmt.Println("error input args ,need outputDir,inputDir ")
		os.Exit(1)
	}

	outputDir := os.Args[1]
	inputDir := os.Args[2]
	targetConfig := ""
	if len(os.Args) > 3 {
		targetConfig = os.Args[3]
	}

	if targetConfig == "" {
		// load all
		{{.PackageName}}.ParserAllConfig(outputDir, inputDir)
	} else {
		{{.PackageName}}.ParserConfig(targetConfig, inputDir, outputDir)
	}
}

`
