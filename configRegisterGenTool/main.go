package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"io/ioutil"
	"os"
	"text/template"
)

const defaultCodeTemplate = `// Generated by gen-tool
// DO NOT EDIT!
package {{.PackageName}}

{{if gt (.Structs|len) 0}}
import (	
	"reflect"
	"github.com/Blizzardx/GoConfigTool/configManager"
)
{{end}}

func init() {
	{{range .Structs}}
	configManager.RegisterType(reflect.TypeOf((*{{.Name}})(nil)).Elem())
	{{end}}
}

`

type TemplateInfo struct {
	PackageName string
	Structs     []*Field
}
type Field struct {
	Name string
}

func main() {

	if len(os.Args) < 3 {

		fmt.Println("error input args ,need configDirectory,registerFileOutputName,templateCode(can be null) ")
		os.Exit(1)
	}

	configDirectory := os.Args[1]
	registerFileOutputName := os.Args[2]
	templateCode := ""
	if len(os.Args) > 3 {
		templateCode = os.Args[3]
	}

	doGen(configDirectory, registerFileOutputName, templateCode)
}

//生成代码
func doGen(workDirectory string, outputFileName string, templateContent string) {
	files, _ := ioutil.ReadDir(workDirectory)

	packageName := ""
	var structNameList []string

	fs := token.NewFileSet()
	for _, fileElem := range files {

		if fileElem.IsDir() {
			continue
		}

		file, err := parser.ParseFile(fs, workDirectory+fileElem.Name(), nil, parser.ParseComments)

		if err != nil {
			fmt.Println(err)
			os.Exit(1)
		}

		pkgName, structNameLst := parse(file)
		if pkgName != "" {
			packageName = pkgName
		}
		structNameList = append(structNameList, structNameLst...)
	}

	templateClass := &TemplateInfo{
		PackageName: packageName,
	}
	fmt.Println("packageName : " + packageName)
	for _, structNameElem := range structNameList {
		fmt.Println("structName : " + structNameElem)
		templateClass.Structs = append(templateClass.Structs, &Field{Name: structNameElem})
	}

	codeTemplate := templateContent
	if codeTemplate == "" {
		codeTemplate = defaultCodeTemplate
	}
	outputStr := generateCode(defaultCodeTemplate, templateClass)
	if nil == outputStr {
		return
	}

	// out put file
	err := ioutil.WriteFile(workDirectory+outputFileName, outputStr, 0666)
	if nil != err {
		fmt.Println(err)
		os.Exit(1)
		return
	}
}

//解析目标文件中的struct
func parse(fileNode *ast.File) (packageName string, structNameList []string) {

	packageName = fileNode.Name.Name

	ast.Inspect(fileNode, func(n ast.Node) bool {

		switch typeSpec := n.(type) {
		case *ast.TypeSpec:

			switch typeSpec.Type.(type) {
			case *ast.StructType:
				structNameList = append(structNameList, typeSpec.Name.Name)
			}
		}

		return true
	})
	return
}

//根据模板生成代码
func generateCode(templateStr string, model interface{}) []byte {

	var err error

	var bf bytes.Buffer

	tpl, err := template.New("Template").Parse(templateStr)
	if err != nil {
		goto OnError
	}

	err = tpl.Execute(&bf, model)
	if err != nil {
		goto OnError
	}

	if err = formatCode(&bf); err != nil {
		fmt.Println("format golang code err", err)
	}

	fmt.Println(string(bf.Bytes()))

	return bf.Bytes()

OnError:
	fmt.Println(err)
	os.Exit(1)
	return nil
}

//格式化go文件
func formatCode(bf *bytes.Buffer) error {

	fset := token.NewFileSet()

	ast, err := parser.ParseFile(fset, "", bf, parser.ParseComments)
	if err != nil {
		return err
	}

	bf.Reset()

	err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(bf, fset, ast)
	if err != nil {
		return err
	}

	return nil
}
