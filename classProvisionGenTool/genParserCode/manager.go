package genParserCode

import "github.com/Blizzardx/GoConfigTool/classProvisionGenTool/define"

//生成配置解析代码

type ExcelConfigInfo struct {
	Content   [][]string
	Provision *define.ConfigInfo
}

func GenParserCode(outputDir string, configInfoList []*ExcelConfigInfo) error {

	return nil
}

type GenParserCodeTableInfo struct {
	PackageName        string
	ClassName          string
	LineClassName      string
	TableTemplate      string                    // read template data
	LineFieldList      []*GenParserCodeFieldInfo // read template data
	IsNeedImportString string                    //"strings"
}
type GenParserCodeFieldInfo struct {
	FieldTemplate string
}

const codeTemplate = `// Generated by gen-tool
// DO NOT EDIT!
package {{.PackageName}}

import (
	"errors"
	"fmt"
	"github.com/Blizzardx/GoConfigTool/common"
	"strconv"
	{{.IsNeedImportString}}
)

func ParserConfig_{{.ClassName}}(decoder common.ConfigDecoder, configContent [][]string) ([]byte, error) {
	{{.TableTemplate}}

	content, err := decoder.Encode(table)
	if nil != err {
		return nil, err
	}
	return content.([]byte), nil
}
func ParserLine_{{.ClassName}}(lineContent []string) (*{{.LineClassName}}, error) {
	line := &{{.LineClassName}}{}
	var err error = nil
	columnIndex := 0

{{range .LineFieldList}}
	{{.FieldTemplate}}
	{{end}}

	return line, nil
}

`

type GenParserCode_TableList struct {
	ClassName string
}

const codeTemplate_TableList = `

	table := &{{.ClassName}}{}
	for line, lineContent := range configContent {
		lineElem, err := ParserLine_{{.ClassName}}(lineContent)
		if nil != err {
			str := fmt.Sprintf("error on load config itemConfigTable at line: " + strconv.Itoa(line+1) + " " + err.Error())
			return nil, errors.New(str)
		}
		table.Content = append(table.Content, lineElem)
	}

`

type GenParserCode_TableMap struct {
	ClassName       string
	LineClassName   string
	MapKeyFieldName string
}

const codeTemplate_TableMap = `

	table := &{{.ClassName}}{}
	table.Content = map[int32]*{{.LineClassName}}{}
	for line, lineContent := range configContent {
		lineElem, err := ParserLine_{{.ClassName}}(lineContent)
		if nil != err {
			str := fmt.Sprintf("error on load config itemConfigTable at line: " + strconv.Itoa(line+1) + " " + err.Error())
			return nil, errors.New(str)
		}

		if v, ok := table.Content[lineElem.{{.MapKeyFieldName}}]; ok {
			str := fmt.Sprintf("error on load config itemConfigTable at line: "+strconv.Itoa(line+1)+" key {{.MapKeyFieldName}} already in table ", v)
			return nil, errors.New(str)
		}
		table.Content[lineElem.{{.MapKeyFieldName}}] = lineElem
	}

`

type GenParserCode_Field struct {
	FieldType          string
	FieldName          string
	LimitCheckTemplate string
}

const codeTemplate_Field = `

	err = common.Parser_{{.FieldType}}(lineContent[columnIndex], &line.{{.FieldName}})
	if nil != err {
		return nil, errors.New(" column " + strconv.Itoa(columnIndex) + " named {{.FieldName}} " + err.Error())
	}

	{{.LimitCheckTemplate}}

	columnIndex++

`

const codeTemplate_FieldEmpty = `
	columnIndex++
`

type GenParserCode_CheckFieldLimit struct {
	FieldType     string
	FieldName     string
	FieldLimitMin string
	FieldLimitMax string
}

const codeTemplate_CheckFieldLimit = `

	err = common.CheckValueLimit_{{.FieldType}}(line.{{.FieldName}}, "{{.FieldLimitMin}}", "{{.FieldLimitMax}}")
	if err != nil {
		return nil, errors.New(" column " + strconv.Itoa(columnIndex) + " named {{.FieldName}} error on check min and max" + err.Error())
	}

`

type GenParserCode_FieldList struct {
	FieldType          string
	FieldName          string
	LimitCheckTemplate string
}

const codeTemplate_FieldList = `

	for _,lineElem := range strings.Split(lineContent[columnIndex],"|"){
		var elem {{.FieldType}} 
		err = common.Parser_{{.FieldType}}(lineElem, &elem)
		if nil != err {
			return nil, errors.New(" column " + strconv.Itoa(columnIndex)  + err.Error())
		}
		
		{{.LimitCheckTemplate}}
		
		{{.FieldName}} = append({{.FieldName}},elem)
	}
	columnIndex++

`

type GenParserCode_CheckFieldListLimit struct {
	FieldType     string
	FieldLimitMin string
	FieldLimitMax string
}

const codeTemplate_CheckFieldListLimit = `

	err = common.CheckValueLimit_{{.FieldType}}(elem, "{{.FieldLimitMin}}", "{{.FieldLimitMax}}")
	if err != nil {
		return nil, errors.New(" column " + strconv.Itoa(columnIndex) + "  error on check min and max" + err.Error())
	}

`
